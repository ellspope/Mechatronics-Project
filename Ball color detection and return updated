
#include "xc.h"

#pragma config FNOSC = LPFRC //choose the internal 500 kHz oscillator
#pragma config OSCIOFNC = OFF   // Turn off clock output on pin 8
#pragma config SOSCSRC = DIG    // Turn off secondary oscillator on pins 9&10

void config_ad(void);


int steps = 0;
int time = 31250;
void __attribute__((interrupt, no_auto_psv)) _OC1Interrupt(void)
{

    _OC1IF = 0;
     steps ++ ;
    // this function is called
}

void delay(void);
void turn_right(void);
void turn_left(void);





int ball_color = 0;

int main() {
    config_ad();
   
   
     // CONFIGURE PINS
   
    // Pin 3 determines direction of left motor
    _ANSA1 = 0; //pin 3 is digital
    _TRISA1 = 0; //pin 3 is an output
   
    // Pin 13 determines direction of right motor
    //pin 13 defaults to digital, it cannot do analog, so we don't have to configure that part of it
    _TRISB9 = 0; //pin 13 is an output
   
     // interrupt for pin 14
    _OC1IE = 1; //ENABLE CN
    _OC1IP = 6; // SET CN INTERRUPT PRIORITY
    _OC1IF = 0; // CLEAR INTERRUPT FLAG
   
   
     // Postscale oscillator
    _RCDIV = 0b000;             // Divide-by-1 postscaler
   
    // Configure pin 2 (RB0) as analog input for QRD
    _TRISA0 = 1;
    _ANSA0 = 1;
   
    // Configure pin 6 (RB2) as digital out for LED
    _TRISB2 = 0; // output
    _ANSB2 = 0; // digital
   
    // Configure PWM for pin 14 (LEFT motor)
    OC1CON1 = 0;                // Clear all bits of OC1CON1
    OC1CON2 = 0;                // Clear all bits of OC1CON2
    OC1CON1bits.OCTSEL = 0b111; // System clock as timing source
    OC1CON2bits.SYNCSEL = 0x1F; // Self-synchronization
    OC1CON2bits.OCTRIG = 0;     // Synchronization mode
    OC1CON1bits.OCM = 0b110;    // Edge-aligned PWM mode
   
    // Configure PWM for pin 4 (RIGHT motor)
    OC2CON1 = 0;                // Clear all bits of OC1CON1
    OC2CON2 = 0;                // Clear all bits of OC1CON2
    OC2CON1bits.OCTSEL = 0b111; // System clock as timing source
    OC2CON2bits.SYNCSEL = 0x1F; // Self-synchronization
    OC2CON2bits.OCTRIG = 0;     // Synchronization mode
    OC2CON1bits.OCM = 0b110;    // Edge-aligned PWM mode
   
    // Configure PWM for pin 5 (servo motor)
    OC3CON1 = 0;                // Clear all bits of OC3CON1
    OC3CON2 = 0;                // Clear all bits of OC3CON2
    OC3CON1bits.OCTSEL = 0b111; // System clock as timing source
    OC3CON2bits.SYNCSEL = 0x1F; // Self-synchronization
    OC3CON2bits.OCTRIG = 0;     // Synchronization mode
    OC3CON1bits.OCM = 0b110;    // Edge-aligned PWM mode
   
    // Initialize OC3RS and OC3R
    OC3RS = 4999; // 50 Hz PWM frequency
    OC3R = 425;
   
    // Initialize OC1RS and OC1R and 2
    OC1RS = 0;
    OC1R = OC1RS * 0.5; // 50% duty cycle
    OC2RS = 0;
    OC2R = OC1RS * 0.5; // 50% duty cycle
   
    // Configure Timer1
    _TON = 1; // Turn Timer1 on
    _TCS = 0; // Internal clock source (F_OSC/2)
    _TCKPS = 0b10; // 1:64 prescaling
    TMR1 = 0; // Reset Timer1
   
//    while (1) {
//        if (ADC1BUF0 <= 2400) { // if ball is white
//            // turn right and pour
//            
//            _LATB2 = 1; // LED on
//        }
//
//        else { // ball is black
//            // turn left
//            _LATB2 = 0; // LED OFF
//        }
//    }
    int temp_time = 0;
    int scanned = 0; // 0 = color not scanned, 1 = color scanned
   
    while (1) {
        if ((TMR1 < 3906.25*4) && (scanned == 0)) { // If Timer1 < 4s and color not scanned
            if (ADC1BUF0 <= 2400) { // if ball is white
                ball_color = 1;
                //_LATB2 = 1;
            }
            else { // ball is black
                //_LATB2 = 0; // LED OFF
            }
        }
        else {
            _LATB2 = 1;
            //_TON = 0; // Turn off Timer1
            scanned = 1;
            if (ball_color == 0){ // If ball is black
                // Code here to turn right 90 deg
                turn_right();
                //_TON = 1; // Turn Timer1 back on
                //TMR1 = 0; // Initialize timer1
                while (OC3R > 175) {
                    if ((TMR1-temp_time)> 400){
                        //OC3R = 125; // 0 deg
                        temp_time = TMR1;
                            OC3R -= 5;
                    }
                }
            }
            else if (ball_color == 1){ // If ball is white
                // Code here to turn left 90 deg
                turn_left();
                //_TON = 1; // Turn Timer1 back on
                //TMR1 = 0; // Initialize timer1
               
                while (OC3R > 175) {
                    if ((TMR1-temp_time)> 400){
                        //OC3R = 125; // 0 deg
                        temp_time = TMR1;
                            OC3R -= 5;
                    }
                }
            }
        }
       
    }
        return 0;
}

void config_ad(void)
{
   
    _ADON = 0;          // AD1CON1<15> -- Turn off A/D during config
   
    // Clear all A/D registers
    AD1CON1 = 0;
    AD1CON2 = 0;
    AD1CON3 = 0;
    AD1CON5 = 0;
    AD1CSSL = 0;
    AD1CSSH = 0;
   
    // AD1CON1 register
    _ADSIDL = 0;    // AD1CON1<13> -- A/D continues while in idle mode
    _MODE12 = 1;    // AD1CON1<10> -- 12-bit A/D operation
    _FORM = 0;      // AD1CON1<9:8> -- Unsigned integer output
    _SSRC = 7;      // AD1CON1<7:4> -- Auto conversion (internal counter)
    _ASAM = 1;      // AD1CON1<2> -- Auto sampling

    // AD1CON2 register
    _PVCFG = 0;     // AD1CON2<15:14> -- Use VDD as positive ref voltage
    _NVCFG = 0;     // AD1CON2<13> -- Use VSS as negative ref voltage
    _BUFREGEN = 1;  // AD1CON2<11> -- Result appears in buffer
                    // location corresponding to channel, e.g., AN12
                    // results appear in ADC1BUF12
    _CSCNA = 1;     // AD1CON2<10> -- Does not scan inputs specified in AD1CSSx
                    // registers
    _SMPI = 0;      // AD1CON2<6:2> -- Results sent to buffer after n conversion
                    // For example, if you are sampling 4 channels, you
                    // should have _SMPI = 3;
    _ALTS = 0;      // AD1CON2<0> -- Sample MUXA only

    // AD1CON3 register
    _ADRC = 0;      // AD1CON3<15> -- Use system clock
    _SAMC = 1;      // AD1CON3<12:8> -- Auto sample every A/D period TAD
    _ADCS = 0;      // AD1CON3<7:0> -- A/D period TAD = TCY
   
    // AD1CHS register
    _CH0NA = 0;     // AD1CHS<7:5> -- Measure voltages relative to VSS
    _CH0SA = 0;    // AD1CHS<4:0> -- Use AN0 (2) as positive input
   
   
    _ADON = 1;      // AD1CON1<15> -- Turn on A/D
    _CSS0 = 1;
}

void delay(void) {
    TMR1 = 0;
    while (TMR1 < time/2) {
        OC1R = 0;
        OC2R = 0;
    }
}
void turn_right(void) {
    steps = 0;
    OC1R = 0; // 0% duty cycle > left off
    OC2R = 0; // 0% duty cycle > right off
    delay();
    while(steps <= 140 * 2) {
            _LATA1 = 1; //  LEFT clockwise
            _LATB9 = 0; //  RIGHT counter clockwise
            OC1RS = 1249 * 2 ;
            OC1R = OC1RS * 0.5;
            OC2RS = 1249 * 2 ;
            OC2R = OC1RS * 0.5;
             
    }

           
             
}

void turn_left(void) {
    steps = 0;
    OC1R = 0; // 0% duty cycle > left off
    OC2R = 0; // 0% duty cycle > right off
    delay();
    while(steps <= 140 * 2) {
            _LATA1 = 0; //  LEFT clockwise
            _LATB9 = 1; //  RIGHT counter clockwise
            OC1RS = 1249 * 2 ;
            OC1R = OC1RS * 0.5;
            OC2RS = 1249 * 2 ;
            OC2R = OC1RS * 0.5;
             
    }

           
             
}
